import jwt from "jsonwebtoken";
import {NextFunction, Request, Response} from "express";
import IUserEntity from "../entities/UserEntity/IUserEntity";
import {validateOrReject} from "class-validator";
import UserDtoRequest from "../dtos/UserDto/UserDtoRequest";

interface AuthenticatedRequest extends Request {
    user?: IUserEntity;
}

export default class {
    static auth = (req: AuthenticatedRequest, res: Response, next: NextFunction) => {
        try {
            const authToken = req?.header("Authorization");
            const token = authToken?.split(" ")[1];

            if (!token) return res.status(403).send("Access denied.");

            if (!process.env.TOKEN_SECRET) {
                throw new Error('TOKEN_SECRET is not defined');
            }

            const decoded = jwt.verify(token, process.env.TOKEN_SECRET);

            req.user = decoded as IUserEntity;
            next();
        } catch (error) {
            console.warn(error);
            res.status(400).send("Invalid token");
        }
    };

    static userValidator = async (
        req: Request,
        res: Response,
        next: NextFunction
    ) => {
        try {
            if (!req.body) {
                return res.status(400).send({ message: 'Missing request body!' });
            }

            // creates new product instance and assigns it data from request.body
            const userDtoRequest = new UserDtoRequest();
            // userDtoRequest.id = req.body.id;
            userDtoRequest.username = req.body.username;
            userDtoRequest.password = req.body.password;

            // checks a product instance against the schema validations
            await validateOrReject(userDtoRequest);

            // calls the next operation
            next();
        } catch (e: any) {
            // handles the error generated by class-validator
            const message = Object.values(e[0].constraints)[0];
            res.status(400).send({ message });
        }
    };
}
